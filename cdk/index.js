"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const autoscaling = require("aws-cdk-lib/aws-autoscaling");
const iam = require("aws-cdk-lib/aws-iam");
const ec2 = require("aws-cdk-lib/aws-ec2");
const eks = require("aws-cdk-lib/aws-eks");
const cdk = require("aws-cdk-lib");
class EKSCluster extends cdk.Stack {
    constructor(scope, id, props) {
        super(scope, id, props);
        const vpc = new ec2.Vpc(this, 'EKSVpc'); // Create a new VPC for our cluster
        const clusterAdmin = new iam.Role(this, 'AdminRole', {
            assumedBy: new iam.AccountRootPrincipal()
        });
        // IAM role for our EC2 worker nodes
        const workerRole = new iam.Role(this, 'EKSWorkerRole', {
            assumedBy: new iam.ServicePrincipal('ec2.amazonaws.com')
        });
        const eksCluster = new eks.Cluster(this, 'Cluster', {
            clusterName: "myEKS",
            mastersRole: clusterAdmin,
            vpc: vpc,
            defaultCapacity: 1,
            version: eks.KubernetesVersion.V1_21,
        });
        const onDemandASG = new autoscaling.AutoScalingGroup(this, 'OnDemandASG', {
            vpc: vpc,
            role: workerRole,
            minCapacity: 1,
            maxCapacity: 10,
            instanceType: new ec2.InstanceType('t3.nano'),
            machineImage: new eks.EksOptimizedImage({
                kubernetesVersion: '1.21',
                nodeType: eks.NodeType.STANDARD // without this, incorrect SSM parameter for AMI is resolved
            }),
            updatePolicy: autoscaling.UpdatePolicy.rollingUpdate()
        });
        eksCluster.connectAutoScalingGroupCapacity(onDemandASG, {});
    }
}
const app = new cdk.App();
new EKSCluster(app, 'MyEKSCluster');
app.synth();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDJEQUE0RDtBQUM1RCwyQ0FBNEM7QUFDNUMsMkNBQTRDO0FBQzVDLDJDQUE0QztBQUM1QyxtQ0FBb0M7QUFFcEMsTUFBTSxVQUFXLFNBQVEsR0FBRyxDQUFDLEtBQUs7SUFDaEMsWUFBWSxLQUFjLEVBQUUsRUFBVSxFQUFFLEtBQXNCO1FBQzVELEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRXhCLE1BQU0sR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBRSxtQ0FBbUM7UUFFN0UsTUFBTSxZQUFZLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxXQUFXLEVBQUU7WUFDbkQsU0FBUyxFQUFFLElBQUksR0FBRyxDQUFDLG9CQUFvQixFQUFFO1NBQ3hDLENBQUMsQ0FBQztRQUVMLG9DQUFvQztRQUNwQyxNQUFNLFVBQVUsR0FBRyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLGVBQWUsRUFBRTtZQUNyRCxTQUFTLEVBQUUsSUFBSSxHQUFHLENBQUMsZ0JBQWdCLENBQUMsbUJBQW1CLENBQUM7U0FDekQsQ0FBQyxDQUFDO1FBRUgsTUFBTSxVQUFVLEdBQUcsSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUU7WUFDbEQsV0FBVyxFQUFFLE9BQU87WUFDcEIsV0FBVyxFQUFFLFlBQVk7WUFDekIsR0FBRyxFQUFFLEdBQUc7WUFDUixlQUFlLEVBQUUsQ0FBQztZQUNsQixPQUFPLEVBQUUsR0FBRyxDQUFDLGlCQUFpQixDQUFDLEtBQUs7U0FDckMsQ0FBQyxDQUFDO1FBRUgsTUFBTSxXQUFXLEdBQUcsSUFBSSxXQUFXLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLGFBQWEsRUFBRTtZQUN4RSxHQUFHLEVBQUUsR0FBRztZQUNSLElBQUksRUFBRSxVQUFVO1lBQ2hCLFdBQVcsRUFBRSxDQUFDO1lBQ2QsV0FBVyxFQUFFLEVBQUU7WUFDZixZQUFZLEVBQUUsSUFBSSxHQUFHLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQztZQUM3QyxZQUFZLEVBQUUsSUFBSSxHQUFHLENBQUMsaUJBQWlCLENBQUM7Z0JBQ3RDLGlCQUFpQixFQUFFLE1BQU07Z0JBQ3pCLFFBQVEsRUFBRSxHQUFHLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBRSw0REFBNEQ7YUFDOUYsQ0FBQztZQUNGLFlBQVksRUFBRSxXQUFXLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRTtTQUNyRCxDQUFDLENBQUM7UUFFTCxVQUFVLENBQUMsK0JBQStCLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzlELENBQUM7Q0FDRjtBQUVELE1BQU0sR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBQzFCLElBQUksVUFBVSxDQUFDLEdBQUcsRUFBRSxjQUFjLENBQUMsQ0FBQztBQUNwQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXV0b3NjYWxpbmcgPSByZXF1aXJlKCdhd3MtY2RrLWxpYi9hd3MtYXV0b3NjYWxpbmcnKTtcbmltcG9ydCBpYW0gPSByZXF1aXJlKCdhd3MtY2RrLWxpYi9hd3MtaWFtJyk7XG5pbXBvcnQgZWMyID0gcmVxdWlyZSgnYXdzLWNkay1saWIvYXdzLWVjMicpO1xuaW1wb3J0IGVrcyA9IHJlcXVpcmUoJ2F3cy1jZGstbGliL2F3cy1la3MnKTtcbmltcG9ydCBjZGsgPSByZXF1aXJlKCdhd3MtY2RrLWxpYicpO1xuXG5jbGFzcyBFS1NDbHVzdGVyIGV4dGVuZHMgY2RrLlN0YWNrIHtcbiAgY29uc3RydWN0b3Ioc2NvcGU6IGNkay5BcHAsIGlkOiBzdHJpbmcsIHByb3BzPzogY2RrLlN0YWNrUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIHByb3BzKTtcblxuICAgIGNvbnN0IHZwYyA9IG5ldyBlYzIuVnBjKHRoaXMsICdFS1NWcGMnKTsgIC8vIENyZWF0ZSBhIG5ldyBWUEMgZm9yIG91ciBjbHVzdGVyXG4gICAgXG4gICAgY29uc3QgY2x1c3RlckFkbWluID0gbmV3IGlhbS5Sb2xlKHRoaXMsICdBZG1pblJvbGUnLCB7XG4gICAgICBhc3N1bWVkQnk6IG5ldyBpYW0uQWNjb3VudFJvb3RQcmluY2lwYWwoKVxuICAgICAgfSk7XG5cbiAgICAvLyBJQU0gcm9sZSBmb3Igb3VyIEVDMiB3b3JrZXIgbm9kZXNcbiAgICBjb25zdCB3b3JrZXJSb2xlID0gbmV3IGlhbS5Sb2xlKHRoaXMsICdFS1NXb3JrZXJSb2xlJywge1xuICAgICAgYXNzdW1lZEJ5OiBuZXcgaWFtLlNlcnZpY2VQcmluY2lwYWwoJ2VjMi5hbWF6b25hd3MuY29tJylcbiAgICB9KTtcblxuICAgIGNvbnN0IGVrc0NsdXN0ZXIgPSBuZXcgZWtzLkNsdXN0ZXIodGhpcywgJ0NsdXN0ZXInLCB7XG4gICAgICBjbHVzdGVyTmFtZTogXCJteUVLU1wiLFxuICAgICAgbWFzdGVyc1JvbGU6IGNsdXN0ZXJBZG1pbixcbiAgICAgIHZwYzogdnBjLFxuICAgICAgZGVmYXVsdENhcGFjaXR5OiAxLCAgLy8gd2Ugd2FudCB0byBtYW5hZ2UgY2FwYWNpdHkgb3VyIHNlbHZlc1xuICAgICAgdmVyc2lvbjogZWtzLkt1YmVybmV0ZXNWZXJzaW9uLlYxXzIxLFxuICAgIH0pO1xuXG4gICAgY29uc3Qgb25EZW1hbmRBU0cgPSBuZXcgYXV0b3NjYWxpbmcuQXV0b1NjYWxpbmdHcm91cCh0aGlzLCAnT25EZW1hbmRBU0cnLCB7XG4gICAgICB2cGM6IHZwYyxcbiAgICAgIHJvbGU6IHdvcmtlclJvbGUsXG4gICAgICBtaW5DYXBhY2l0eTogMSxcbiAgICAgIG1heENhcGFjaXR5OiAxMCxcbiAgICAgIGluc3RhbmNlVHlwZTogbmV3IGVjMi5JbnN0YW5jZVR5cGUoJ3QzLm5hbm8nKSxcbiAgICAgIG1hY2hpbmVJbWFnZTogbmV3IGVrcy5Fa3NPcHRpbWl6ZWRJbWFnZSh7XG4gICAgICAgIGt1YmVybmV0ZXNWZXJzaW9uOiAnMS4yMScsXG4gICAgICAgIG5vZGVUeXBlOiBla3MuTm9kZVR5cGUuU1RBTkRBUkQgIC8vIHdpdGhvdXQgdGhpcywgaW5jb3JyZWN0IFNTTSBwYXJhbWV0ZXIgZm9yIEFNSSBpcyByZXNvbHZlZFxuICAgICAgfSksXG4gICAgICB1cGRhdGVQb2xpY3k6IGF1dG9zY2FsaW5nLlVwZGF0ZVBvbGljeS5yb2xsaW5nVXBkYXRlKClcbiAgICAgIH0pO1xuXG4gICAgZWtzQ2x1c3Rlci5jb25uZWN0QXV0b1NjYWxpbmdHcm91cENhcGFjaXR5KG9uRGVtYW5kQVNHLCB7fSk7XG4gIH1cbn1cblxuY29uc3QgYXBwID0gbmV3IGNkay5BcHAoKTtcbm5ldyBFS1NDbHVzdGVyKGFwcCwgJ015RUtTQ2x1c3RlcicpO1xuYXBwLnN5bnRoKCk7Il19